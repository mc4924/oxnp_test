#include <unistd.h>
#include <string>
#include <vector>
#include <algorithm>
#include <fstream>
#include <sstream>
#include <iostream>

#include "H5Cpp.h"

#include "cmn.h"


using namespace std;
using namespace H5;


/*
Verfication of files generated by the reader processes.
Opens a series of HDF5 files that have been generated in sequence, reads
all the data points in them and verifies that the datapoints (in order)
match the generating function 'generate()' in cmn.h (possibly modified
by the 'transform()' function.
*/

bool do_transform=false;
bool quiet=false;

/*
On the command line:

    verify_results [--transform]  [--quiet]  file ...

        file ...    : a list of the HDF5 file names
        --transform : apply the 'transform()' function
        --quiet     : just print errors or successful result
*/
int main(int argc, char *argv[])
{
    // The cmd line arguments are the files to read for verification.
    // put them in a vector
    vector<string> filenames;

    for (int k=1;k<argc;k++) {
       if (strcmp(argv[k],"--transform")==0)
           do_transform=true;
       else if (strcmp(argv[k],"--quiet")==0)
           quiet=true;
       else
           filenames.push_back(argv[k]);
    }

    // The filenames end with a sequence number, so we sort them to have them
    // all in order
    sort(filenames.begin(),filenames.end());

    size_t mismatch_count=0;


    size_t j=0; // global index for all the points
    for (auto filename: filenames) {

        H5File file(H5std_string(filename), H5F_ACC_RDONLY);
        DataSet dataset = file.openDataSet(H5std_string(DATASET_NAME));
        DataSpace dataspace=dataset.getSpace();

        vector<hsize_t> dims(dataspace.getSimpleExtentNdims());
        dataspace.getSimpleExtentDims(&dims[0]);

        size_t n_points=dims[0];

        if (!quiet)
            cout << filename << " " << n_points << " data points" << endl;

        hsize_t offset[1]={0};

        // Read the file data points ...
        while (n_points) {

            // one 'membuf[]' chunk at a time
            const size_t MEMBUF_SIZE=65536;
            data_point_t  membuf[MEMBUF_SIZE];

            // how many to read this time
            size_t n = (n_points<MEMBUF_SIZE)? n_points : MEMBUF_SIZE;

            // Read n data points
            hsize_t memdim[1]={n};
            hsize_t count[1]={n};
            hsize_t stride[1]={1};
            hsize_t block[1]={1};
            DataSpace memspace(1, memdim);
            dataspace.selectHyperslab(H5S_SELECT_SET, count, offset, stride, block);

            dataset.read(membuf, PredType::NATIVE_DOUBLE,memspace,dataspace);

            // Verify if the points that have been read match with the reference
            for (int k=0;k<n;k++) {
                data_point_t x     = membuf[k];

                data_point_t x_ref = generate(j);

                if (do_transform)
                    x_ref = transform(j,x_ref);

                if (x!=x_ref) {
                    static bool do_print=true;
                    mismatch_count++;

                    // Just print the few errors and then no more (but count them all)
                    if (do_print) {
                        if (mismatch_count<30) {
                            cerr << "ERROR: mismatch at data point " << j << " (file " << filename << "): "
                                 << x << " instead of " << x_ref << endl;
                        } else {
                            cerr << "ERROR: more mismatches not printed ..." << endl;
                            do_print=false;
                        }
                    }
                }

                j++;
           }


            offset[0] += n;
            n_points  -= n;

        } // loop reading one file

    } // all files

    if (mismatch_count==0)
        cout << "Verification successful" << endl;
    else
        cout << "ERROR: " << mismatch_count << " mismatches found" << endl;
    return 0;
}
